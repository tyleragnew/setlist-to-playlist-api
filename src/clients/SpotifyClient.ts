import { HttpService } from '@nestjs/axios';
import { Injectable } from '@nestjs/common';
import { SPOTIFY_BASE_URL } from 'src/constants';
import { AverageSetlist } from 'src/services/SetlistService';

type MappedSongMetadata = {
  songTitle: string;
  spotifySongId: string;
};

export type PlaylistMetadata = {
  artistName: string;
  mappedSongs: MappedSongMetadata[];
  unmappedSongs: string[];
};

@Injectable()
export class SpotifyClient {
  constructor(private readonly httpService: HttpService) {}

  async getUserIdByApiKey(apiKey: string): Promise<string> {
    const headers = {
      Authorization: `Bearer ${apiKey}`,
    };

    // Setlist.FM automatically shows the most recent shows first.
    const response = await this.httpService
      .get(`https://api.spotify.com/v1/me`, { headers })
      .toPromise();
    return response.data.id;
  }

  //Get TrackID's by Artist Name and Track Names
  async getTrackIdsbyArtistNameAndTrackNames(
    averageSetlist: AverageSetlist,
    apiKey: string,
  ): Promise<PlaylistMetadata> {
    const headers = {
      Authorization: `Bearer ${apiKey}`,
    };

    try {
      const requests = averageSetlist.songs.map((song) =>
        this.httpService
          .get(this.generateURL(song, averageSetlist.artistName), { headers })
          .toPromise(),
      );

      const foundTracks: MappedSongMetadata[] = [];
      const unfoundTracks: string[] = [];

      const responses = await Promise.all(requests);

      responses.forEach((response) => {
        const track = response.data.tracks.items[0];
        if (track != null) {
          const trackMetadata: MappedSongMetadata = {
            songTitle: track.name,
            spotifySongId: track.id,
          };
          foundTracks.push(trackMetadata);
        } else {
          //@TODO - figure out something to do with medleys...
          const urlParams = new URLSearchParams(response.data.tracks.href);
          const queryParamValue = urlParams
            .get(`${SPOTIFY_BASE_URL}?query`)
            .match(/track:(.*?)\sartist:/)[1];
          unfoundTracks.push(queryParamValue);
        }
      });

      return {
        artistName: averageSetlist.artistName,
        mappedSongs: foundTracks,
        unmappedSongs: unfoundTracks,
      };
    } catch (error) {
      console.log(error);
      return error;
    }
  }

  generateURL(songTitle: string, artistTitle: string) {
    const url = `${SPOTIFY_BASE_URL}?q=track:${songTitle.replace(
      / /g,
      '+',
    )} artist:${artistTitle.replace(/ /g, '+')}&type=track&offset=0&limit=1`;
    return url;
  }

  async createPlaylist(
    userId,
    playlistMetadata: PlaylistMetadata,
    apiKey: string,
  ) {
    const headers = {
      Authorization: `Bearer ${apiKey}`,
    };

    try {
      const createPlaylistRequestBody = {
        name: `${playlistMetadata.artistName} Setlist`,
        description: `A representative setlist for ${playlistMetadata.artistName}. Generated by Setlist2Playlist App`,
        public: true,
      };

      const createPlaylistResponse = await this.httpService
        .post(
          `https://api.spotify.com/v1/users/${userId}/playlists`,
          createPlaylistRequestBody,
          { headers },
        )
        .toPromise();

      const playlistId = createPlaylistResponse.data.id;

      const trackData = {
        uris: playlistMetadata.mappedSongs.map(
          (song) => `spotify:track:${song.spotifySongId}`,
        ),
      };

      const modifyPlaylistResponse = await this.httpService
        .put(
          `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
          trackData,
          { headers },
        )
        .toPromise();

      const response = {
        playlistId: playlistId,
        embedURL: `https://open.spotify.com/embed/playlist/${playlistId}?utm_source=generator`,
        unmappedSongs: playlistMetadata.unmappedSongs,
      };

      return response;
    } catch (error) {
      return error;
    }
  }
}
