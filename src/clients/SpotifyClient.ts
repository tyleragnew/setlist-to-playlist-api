import { HttpService } from '@nestjs/axios';
import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
import { AxiosError } from 'axios';
import { SPOTIFY_BASE_URL } from '../constants';
import { AverageSetlist } from '../services/SetlistService';
import { lastValueFrom } from 'rxjs';

type MappedSongMetadata = {
  songTitle: string;
  spotifySongId: string;
};

export type PlaylistMetadata = {
  artistName: string;
  mappedSongs: MappedSongMetadata[];
  unmappedSongs: string[];
};

@Injectable()
export class SpotifyClient {
  constructor(private readonly httpService: HttpService) {}

  private handleRequestError(error: unknown, context: string) {
    // Log useful debug information
    if ((error as AxiosError).isAxiosError) {
      const axiosErr = error as AxiosError;
      console.error(`${context} - AxiosError:`, {
        message: axiosErr.message,
        url: axiosErr.config?.url,
        method: axiosErr.config?.method,
        status: axiosErr.response?.status,
        data: axiosErr.response?.data,
      });
      const status = axiosErr.response?.status || HttpStatus.BAD_GATEWAY;
      const message = axiosErr.response?.data || axiosErr.message;
      // Provide clearer guidance for 401s from Spotify
      if (status === HttpStatus.UNAUTHORIZED) {
        console.error(
          `${context} - 401 Unauthorized from Spotify. Common causes: expired/invalid access token, using client-credentials token for user endpoints, or missing scopes (e.g. playlist-modify-public).`,
        );
        throw new HttpException(
          {
            error: 'Unauthorized: invalid or expired Spotify access token',
            details: message,
            hint: 'Ensure you pass a valid OAuth access token (Authorization Code flow) with required scopes (e.g. playlist-modify-public) and not a client-credentials token. Tokens expire after ~1 hour and must be refreshed.',
          },
          HttpStatus.UNAUTHORIZED,
        );
      }

      throw new HttpException({ error: message }, status);
    }

    // Unknown error
    console.error(`${context} - Unknown error:`, error);
    throw new HttpException(
      'Internal Server Error',
      HttpStatus.INTERNAL_SERVER_ERROR,
    );
  }

  private normalizeToken(apiKey: string) {
    if (!apiKey) return apiKey;
    return apiKey.replace(/^Bearer\s+/i, '').trim();
  }

  async getUserIdByApiKey(apiKey: string): Promise<string> {
    const token = this.normalizeToken(apiKey);
    const headers = {
      Authorization: `Bearer ${token}`,
    };
    try {
      const response = await this.httpService
        .get(`https://api.spotify.com/v1/me`, { headers })
        .toPromise();
      return response.data.id;
    } catch (error) {
      this.handleRequestError(error, 'getUserIdByApiKey');
    }
  }

  /* 
    Get Spotify TrackID's 
    by Artist Name and Track Names 
  */
  async getTrackIdsbyArtistNameAndTrackName(
    averageSetlist: AverageSetlist,
    apiKey: string,
  ): Promise<PlaylistMetadata> {
    const token = this.normalizeToken(apiKey);
    const headers = {
      Authorization: `Bearer ${token}`,
    };

    try {
      const requests = averageSetlist.songs.map((song) =>
        this.httpService
          .get(this.generateSpotifyTrackURL(song, averageSetlist.artistName), {
            headers,
          })
          .toPromise(),
      );

      const foundTracks: MappedSongMetadata[] = [];
      const unfoundTracks: string[] = [];

      console.log(`Getting requests for Spotify Track Urls for Artist`);
      const responses = await Promise.all(requests);

      responses.forEach((response) => {
        const track = response.data.tracks.items[0];
        if (track != null) {
          const trackMetadata: MappedSongMetadata = {
            songTitle: track.name,
            spotifySongId: track.id,
          };
          console.log(`Pushing ${JSON.stringify(track.name)}`);
          foundTracks.push(trackMetadata);
        } else {
          unfoundTracks.push('Unfound Song');
        }
      });

      return {
        artistName: averageSetlist.artistName,
        mappedSongs: foundTracks,
        unmappedSongs: unfoundTracks,
      };
    } catch (error) {
      this.handleRequestError(error, 'getTrackIdsbyArtistNameAndTrackName');
    }
  }

  generateSpotifyTrackURL(songTitle: string, artistTitle: string) {
    const url = `${SPOTIFY_BASE_URL}?q=track:${songTitle.replace(
      / /g,
      '+',
    )} artist:${artistTitle.replace(/ /g, '+')}&type=track&offset=0&limit=1`;
    return url;
  }

  async createPlaylist(
    userId,
    playlistMetadata: PlaylistMetadata,
    apiKey: string,
  ) {
    const token = this.normalizeToken(apiKey);
    const headers = {
      Authorization: `Bearer ${token}`,
    };
    try {
      const createPlaylistRequestBody = {
        name: `${playlistMetadata.artistName} Setlist`,
        description: `A representative setlist for ${playlistMetadata.artistName}. Generated by Setlist2Playlist App`,
        public: true,
      };

      console.log(`Creating Playlist for ${playlistMetadata.artistName}`);
      const createPlaylistResponse = await this.httpService
        .post(
          `https://api.spotify.com/v1/users/${userId}/playlists`,
          createPlaylistRequestBody,
          { headers },
        )
        .toPromise();

      const playlistId = createPlaylistResponse.data.id;

      const trackData = {
        uris: playlistMetadata.mappedSongs.map(
          (song) => `spotify:track:${song.spotifySongId}`,
        ),
      };

      await this.httpService
        .put(
          `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
          trackData,
          { headers },
        )
        .toPromise();

      const response = {
        playlistId: playlistId,
        embedURL: `https://open.spotify.com/embed/playlist/${playlistId}?utm_source=generator`,
        unmappedSongs: playlistMetadata.unmappedSongs,
      };

      return response;
    } catch (error) {
      this.handleRequestError(error, 'createPlaylist');
    }
  }

  getArtistImageByArtistName(artistName: string, apiKey: string) {
    const token = this.normalizeToken(apiKey);
    const headers = {
      Authorization: `Bearer ${token}`,
    };
    return lastValueFrom(
      this.httpService.get(
        `https://api.spotify.com/v1/search?q=${artistName}&type=artist`,
        { headers },
      ),
    ).then((response) => {
      const artistImageURL = response.data.artists.items[0]?.images[0]?.url;
      return artistImageURL;
    });
  }
}
